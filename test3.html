<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Sensor Coverage AR Demo with Sensor Placement (Tapping)</title>
  <!-- A-Frame Library -->
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <!-- AR.js for A-Frame -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #ui-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px;
      background-color: rgba(0, 0, 0, 0.5);
      color: #fff;
      border-radius: 4px;
      z-index: 9999;
    }
    #ui-panel label,
    #ui-panel select,
    #ui-panel input,
    #ui-panel button {
      margin-right: 6px;
      margin-bottom: 6px;
    }
  </style>
  <!-- Custom Geometry for a 3D Elliptical Frustum -->
  <script>
    AFRAME.registerGeometry("ellipticalFrustum", {
      schema: {
        height: { type: "number", default: 2.5 },
        topRadiusX: { type: "number", default: 0.05 },
        topRadiusZ: { type: "number", default: 0.05 },
        bottomRadiusX: { type: "number", default: 1 },
        bottomRadiusZ: { type: "number", default: 1 },
        segments: { type: "number", default: 32 }
      },
      init: function (data) {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];
        const segments = data.segments;
        const height = data.height;
        // Create two circles: top (sensor level) and bottom (floor, y=0)
        for (let i = 0; i < segments; i++) {
          const theta = (i / segments) * Math.PI * 2;
          // Top circle vertex at sensor level
          const xTop = data.topRadiusX * Math.cos(theta);
          const zTop = data.topRadiusZ * Math.sin(theta);
          vertices.push(xTop, height, zTop);
          // Bottom circle vertex at floor level (y=0)
          const xBottom = data.bottomRadiusX * Math.cos(theta);
          const zBottom = data.bottomRadiusZ * Math.sin(theta);
          vertices.push(xBottom, 0, zBottom);
        }
        // Build side faces with two triangles per segment.
        for (let i = 0; i < segments; i++) {
          const next = (i + 1) % segments;
          const topCurrent = i * 2;
          const bottomCurrent = i * 2 + 1;
          const topNext = next * 2;
          const bottomNext = next * 2 + 1;
          indices.push(topCurrent, bottomCurrent, topNext);
          indices.push(topNext, bottomCurrent, bottomNext);
        }
        geometry.setIndex(indices);
        geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });
  </script>
</head>
<body>
<!-- UI Panel for height selection and sensor placement control -->
<div id="ui-panel">
  <div>
    <label for="unitSelect">Units:</label>
    <select id="unitSelect" onchange="populateHeightDropdown()">
      <option value="feet">Feet</option>
      <option value="meters">Meters</option>
    </select>
  </div>
  <div>
    <label for="heightSelect">Ceiling Height:</label>
    <select id="heightSelect">
      <!-- Options populated automatically -->
    </select>
  </div>
  <div>
    <label for="heightInput">Or enter custom:</label>
    <input type="number" step="0.1" id="heightInput" placeholder="e.g. 9.0" style="width:80px;" />
  </div>
  <button onclick="updateCoverage()">Update Coverage</button>
  <br />
  <button onclick="enableSensorPlacement()">Place Sensor</button>
  <span id="placementStatus"></span>
</div>

<!-- AR Scene -->
<a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" vr-mode-ui="enabled: false">
  <!-- Using the "hiro" marker as an anchor -->
  <a-marker preset="hiro" type="pattern">
    <!-- An invisible ground plane for sensor placement (covers a large area) -->
    <a-plane id="groundPlane" position="0 0 0" rotation="-90 0 0" width="10" height="10"
             material="opacity: 0.01; transparent:true"></a-plane>

    <!-- 3D Coverage Volume drawn as an elliptical frustum -->
    <a-entity id="coverageVolume"></a-entity>

    <!-- Sensor Representation: a red box with a "Sensor" label -->
    <a-box id="sensorBox" position="0 2.5 0" width="0.1" height="0.1" depth="0.1" material="color: #ff0000;">
      <a-text value="Sensor" align="center" color="#ff0000" position="0 0.2 0"></a-text>
    </a-box>
  </a-marker>

  <!-- Camera with a cursor for touch/mouse events -->
  <a-entity id="camera" camera look-controls position="0 0 0">
    <!-- The cursor uses rayOrigin 'mouse' so that clicks/taps register -->
    <a-cursor rayOrigin="mouse" fuse="false"></a-cursor>
  </a-entity>
</a-scene>

<script>
  // Global variable to store sensor's horizontal (x, z) position.
  let sensorPos = { x: 0, z: 0 };
  // Flag to control sensor placement mode.
  let sensorPlacementMode = false;

  // Sample coverage data (in feet)
  const coverageDataFeet = [
    { height: 7.5, width: 7.7, length: 9.5 },
    { height: 8.2, width: 9.2, length: 11.4 },
    { height: 9.0, width: 10.0, length: 12.3 },
    { height: 9.5, width: 10.7, length: 13.4 },
    { height: 10.0, width: 11.3, length: 14.5 },
    { height: 11.0, width: 13.8, length: 15.2 }
  ];
  // Convert coverage data to meters (1 ft = 0.3048 m)
  const coverageDataMeters = coverageDataFeet.map(entry => ({
    height: +(entry.height * 0.3048).toFixed(2),
    width: +(entry.width * 0.3048).toFixed(2),
    length: +(entry.length * 0.3048).toFixed(2)
  }));

  const unitSelect = document.getElementById("unitSelect");
  const heightSelect = document.getElementById("heightSelect");
  const heightInput = document.getElementById("heightInput");

  // Populate the height dropdown based on the chosen unit.
  function populateHeightDropdown() {
    heightSelect.innerHTML = "";
    const data = unitSelect.value === "feet" ? coverageDataFeet : coverageDataMeters;
    data.forEach(entry => {
      const option = document.createElement("option");
      option.value = entry.height;
      option.textContent = `${entry.height} ${unitSelect.value === "feet" ? "ft" : "m"}`;
      heightSelect.appendChild(option);
    });
  }
  populateHeightDropdown();

  // Lookup coverage dimensions (width and length) for a given height.
  function findCoverageDimensions(inputHeight, isFeet) {
    const data = isFeet ? coverageDataFeet : coverageDataMeters;
    let exact = data.find(d => d.height === inputHeight);
    if (exact) return { width: exact.width, length: exact.length };
    let closest = data.reduce((prev, curr) =>
            Math.abs(curr.height - inputHeight) < Math.abs(prev.height - inputHeight) ? curr : prev
    );
    return { width: closest.width, length: closest.length };
  }

  // Update the sensor's position and its coverage volume.
  function updateCoverage() {
    const isFeet = unitSelect.value === "feet";
    let chosenHeight = parseFloat(heightSelect.value);
    if (heightInput.value.trim() !== "") {
      chosenHeight = parseFloat(heightInput.value);
    }
    if (isNaN(chosenHeight)) {
      alert("Please enter a valid ceiling height.");
      return;
    }
    // Update the sensor box position (using sensorPos for x and z, and chosen height for y).
    const sensorBox = document.getElementById("sensorBox");
    sensorBox.setAttribute("position", `${sensorPos.x} ${chosenHeight} ${sensorPos.z}`);

    // Get coverage dimensions from the table.
    const { width, length } = findCoverageDimensions(chosenHeight, isFeet);
    const coverageVolume = document.getElementById("coverageVolume");
    coverageVolume.setAttribute("geometry", {
      primitive: "ellipticalFrustum",
      height: chosenHeight,
      topRadiusX: 0.05,
      topRadiusZ: 0.05,
      bottomRadiusX: width / 2,
      bottomRadiusZ: length / 2,
      segments: 32
    });
    // Position the coverage volume at the sensor's (x, z), with its bottom at y=0.
    coverageVolume.setAttribute("position", `${sensorPos.x} 0 ${sensorPos.z}`);

    console.log(`Updated: Height = ${chosenHeight} ${isFeet ? "ft" : "m"}, Width = ${width}, Length = ${length}, SensorPos = (${sensorPos.x}, ${sensorPos.z})`);
  }

  // Enable sensor placement mode.
  function enableSensorPlacement() {
    sensorPlacementMode = true;
    document.getElementById("placementStatus").textContent = "Tap on the ground to place sensor.";
  }

  // Handle sensor placement on the ground plane.
  function sensorPlacementHandler(evt) {
    if (!sensorPlacementMode) return;
    // The event detail contains the intersection data.
    const intersection = evt.detail.intersection;
    if (intersection) {
      sensorPos.x = intersection.point.x;
      sensorPos.z = intersection.point.z;
      updateCoverage();
      sensorPlacementMode = false;
      document.getElementById("placementStatus").textContent = "Sensor placed.";
    }
  }

  // Attach event listeners to the ground plane for both click and touchstart events.
  const groundPlane = document.getElementById("groundPlane");
  groundPlane.addEventListener("click", sensorPlacementHandler);
  groundPlane.addEventListener("touchstart", sensorPlacementHandler);
</script>
</body>
</html>
