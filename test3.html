<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Sensor Coverage AR Demo</title>
  <!-- A-Frame Library -->
  <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
  <!-- AR.js for A-Frame -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #ui-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px;
      background-color: rgba(0, 0, 0, 0.5);
      color: #fff;
      border-radius: 4px;
      z-index: 9999;
    }
    #ui-panel label,
    #ui-panel select,
    #ui-panel input {
      margin-right: 6px;
    }
    #ui-panel button {
      margin-top: 6px;
      padding: 6px 12px;
    }
  </style>

  <!-- Register a custom geometry: an elliptical frustum that represents the 3D coverage volume -->
  <script>
    AFRAME.registerGeometry("ellipticalFrustum", {
      schema: {
        height: { type: "number", default: 2.5 },
        topRadiusX: { type: "number", default: 0.05 },
        topRadiusZ: { type: "number", default: 0.05 },
        bottomRadiusX: { type: "number", default: 1 },
        bottomRadiusZ: { type: "number", default: 1 },
        segments: { type: "number", default: 32 }
      },
      init: function (data) {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];
        const segments = data.segments;
        const height = data.height;
        // Define top circle at y = height (sensor position)
        // and bottom circle at y = 0 (floor)
        for (let i = 0; i < segments; i++) {
          const theta = (i / segments) * Math.PI * 2;
          // Top circle vertex
          const xTop = data.topRadiusX * Math.cos(theta);
          const zTop = data.topRadiusZ * Math.sin(theta);
          vertices.push(xTop, height, zTop);
          // Bottom circle vertex
          const xBottom = data.bottomRadiusX * Math.cos(theta);
          const zBottom = data.bottomRadiusZ * Math.sin(theta);
          vertices.push(xBottom, 0, zBottom);
        }
        // Build side faces (two triangles per segment)
        for (let i = 0; i < segments; i++) {
          const next = (i + 1) % segments;
          const topCurrent = i * 2;
          const bottomCurrent = i * 2 + 1;
          const topNext = next * 2;
          const bottomNext = next * 2 + 1;
          indices.push(topCurrent, bottomCurrent, topNext);
          indices.push(topNext, bottomCurrent, bottomNext);
        }
        geometry.setIndex(indices);
        geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
        geometry.computeVertexNormals();
        this.geometry = geometry;
      }
    });
  </script>
</head>

<body>
<!-- UI Panel -->
<div id="ui-panel">
  <div>
    <label for="unitSelect">Units:</label>
    <select id="unitSelect" onchange="populateHeightDropdown()">
      <option value="feet">Feet</option>
      <option value="meters">Meters</option>
    </select>
  </div>
  <div>
    <label for="heightSelect">Ceiling Height:</label>
    <select id="heightSelect">
      <!-- Options will be populated automatically -->
    </select>
  </div>
  <div>
    <label for="heightInput">Or enter custom:</label>
    <input type="number" step="0.1" id="heightInput" style="width:80px;" placeholder="e.g. 9.0" />
  </div>
  <button onclick="updateCoverage()">Update Coverage</button>
</div>

<!-- AR Scene -->
<a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" vr-mode-ui="enabled: false">
  <!-- Marker-based AR using the "hiro" marker -->
  <a-marker preset="hiro" type="pattern">
    <!-- 3D Coverage Volume -->
    <a-entity id="coverageVolume"></a-entity>

    <!-- Sensor Representation with a label -->
    <a-box id="sensorBox" position="0 2.5 0" width="0.1" height="0.1" depth="0.1" material="color: #ff0000;">
      <a-text value="Sensor" align="center" color="#ff0000" position="0 0.2 0"></a-text>
    </a-box>
  </a-marker>

  <!-- AR Camera -->
  <a-entity camera></a-entity>
</a-scene>

<script>
  /************************************************************
   * 1. COVERAGE TABLE
   *    - Example sensor coverage data.
   *    - Data is provided in feet; a converted version in meters is available.
   ************************************************************/
  const coverageDataFeet = [
    { height: 7.5, width: 7.7, length: 9.5 },
    { height: 8.2, width: 9.2, length: 11.4 },
    { height: 9.0, width: 10.0, length: 12.3 },
    { height: 9.5, width: 10.7, length: 13.4 },
    { height: 10.0, width: 11.3, length: 14.5 },
    { height: 11.0, width: 13.8, length: 15.2 }
  ];

  // Convert feet to meters (1 ft = 0.3048 m)
  const coverageDataMeters = coverageDataFeet.map(entry => ({
    height: +(entry.height * 0.3048).toFixed(2),
    width: +(entry.width * 0.3048).toFixed(2),
    length: +(entry.length * 0.3048).toFixed(2)
  }));

  /************************************************************
   * 2. POPULATE THE HEIGHT DROPDOWN
   ************************************************************/
  const unitSelect = document.getElementById("unitSelect");
  const heightSelect = document.getElementById("heightSelect");
  const heightInput = document.getElementById("heightInput");

  function populateHeightDropdown() {
    heightSelect.innerHTML = "";
    const data = unitSelect.value === "feet" ? coverageDataFeet : coverageDataMeters;
    data.forEach(entry => {
      const option = document.createElement("option");
      option.value = entry.height;
      option.textContent = `${entry.height} ${unitSelect.value === "feet" ? "ft" : "m"}`;
      heightSelect.appendChild(option);
    });
  }

  // Initialize dropdown on load.
  populateHeightDropdown();

  /************************************************************
   * 3. LOOKUP COVERAGE DIMENSIONS
   *    - Returns width and length based on the input height.
   *    - Uses an exact match if available; otherwise, picks the closest entry.
   ************************************************************/
  function findCoverageDimensions(inputHeight, isFeet) {
    const data = isFeet ? coverageDataFeet : coverageDataMeters;
    let exact = data.find(d => d.height === inputHeight);
    if (exact) return { width: exact.width, length: exact.length };

    let closest = data.reduce((prev, curr) =>
            Math.abs(curr.height - inputHeight) < Math.abs(prev.height - inputHeight) ? curr : prev
    );
    return { width: closest.width, length: closest.length };
  }

  /************************************************************
   * 4. UPDATE COVERAGE FUNCTION
   *    - Updates sensor position and regenerates the 3D coverage volume.
   ************************************************************/
  function updateCoverage() {
    const isFeet = unitSelect.value === "feet";
    let chosenHeight = parseFloat(heightSelect.value);
    if (heightInput.value.trim() !== "") {
      chosenHeight = parseFloat(heightInput.value);
    }
    if (isNaN(chosenHeight)) {
      alert("Please enter a valid ceiling height.");
      return;
    }

    // Get coverage dimensions from the table.
    const { width, length } = findCoverageDimensions(chosenHeight, isFeet);

    // Update sensor box position (sensor is at the ceiling).
    const sensorBox = document.getElementById("sensorBox");
    sensorBox.setAttribute("position", `0 ${chosenHeight} 0`);

    // Update 3D coverage volume.
    // Our custom elliptical frustum geometry is defined such that:
    // - Its top is at y = chosenHeight (sensor position)
    // - Its bottom is at y = 0 (floor)
    // For an elliptical shape, bottom radii are half of the full width/length.
    const coverageVolume = document.getElementById("coverageVolume");
    coverageVolume.setAttribute("geometry", {
      primitive: "ellipticalFrustum",
      height: chosenHeight,
      topRadiusX: 0.05,
      topRadiusZ: 0.05,
      bottomRadiusX: width / 2,
      bottomRadiusZ: length / 2,
      segments: 32
    });
    // Position the volume so that its bottom is at y=0.
    coverageVolume.setAttribute("position", "0 0 0");

    console.log(
            `Updated: Height = ${chosenHeight} ${isFeet ? "ft" : "m"}, Width = ${width}, Length = ${length}`
    );
  }
</script>
</body>
</html>
